cat > backend/indices.py <<'PY'
"""
indices.py
คำนวณ 5 indices:
 - NDVI (จาก NIR, RED)
 - EVI  (ต้องการ NIR, RED, BLUE) (ถ้าไม่มี BLUE จะ return None)
 - GNDVI (NIR, GREEN)
 - SAVI  (NIR, RED)
 - NDMI  (NIR, SWIR)

รับ input เป็น dict ของ bands ที่เป็น "scaled-by-100" (เช่น ML model คืน 32.87 หมายถึง reflectance = 0.3287)
ผลลัพธ์เป็น float rounded 2 ตำแหน่ง (หรือ None ถ้าไม่พอข้อมูล)
"""
from typing import Dict, Optional
import math

def _to_reflectance(val_scaled):
    """แปลง value (scaled-by-100) -> reflectance (0-1)"""
    if val_scaled is None:
        return None
    try:
        return float(val_scaled) / 100.0
    except Exception:
        return None

def compute_indices(bands_scaled: Dict[str, float]) -> Dict[str, Optional[float]]:
    """
    bands_scaled: dict เช่น {"red": 32.87, "nir": 45.12, "green": 28.5, "swir": 12.3, "blue": 20.0}
    คืน dict ของ indices เป็น float (2 ตำแหน่ง) หรือ None
    """
    red = _to_reflectance(bands_scaled.get("red"))
    nir = _to_reflectance(bands_scaled.get("nir"))
    green = _to_reflectance(bands_scaled.get("green"))
    swir = _to_reflectance(bands_scaled.get("swir"))
    blue = _to_reflectance(bands_scaled.get("blue"))

    def safe_div(a, b):
        try:
            if a is None or b is None:
                return None
            if (a + b) == 0:
                return None
            return a / b
        except Exception:
            return None

    # NDVI
    ndvi = None
    if nir is not None and red is not None:
        ndvi = (nir - red) / (nir + red) if (nir + red) != 0 else None

    # EVI (requires blue)
    evi = None
    if nir is not None and red is not None and blue is not None:
        # EVI = 2.5 * (NIR - RED) / (NIR + 6*RED - 7.5*BLUE + 1)
        denom = (nir + 6.0 * red - 7.5 * blue + 1.0)
        evi = 2.5 * (nir - red) / denom if denom != 0 else None

    # GNDVI (needs green)
    gndvi = None
    if nir is not None and green is not None:
        gndvi = (nir - green) / (nir + green) if (nir + green) != 0 else None

    # SAVI (soil-adjusted) -> L = 0.5 default
    savi = None
    L = 0.5
    if nir is not None and red is not None:
        savi = ((nir - red) * (1.0 + L)) / (nir + red + L) if (nir + red + L) != 0 else None

    # NDMI (NIR and SWIR)
    ndmi = None
    if nir is not None and swir is not None:
        ndmi = (nir - swir) / (nir + swir) if (nir + swir) != 0 else None

    def _round(v):
        return round(v, 2) if v is not None and (not math.isnan(v)) else None

    return {
        "ndvi": _round(ndvi),
        "evi": _round(evi),
        "gndvi": _round(gndvi),
        "savi": _round(savi),
        "ndmi": _round(ndmi)
    }
PY
