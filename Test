// frontend/src/pages/_app.tsx
import "leaflet/dist/leaflet.css";
import "../styles/globals.css";
import type { AppProps } from "next/app";

function MyApp({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

export default MyApp;
--
/* frontend/src/styles/globals.css */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
  background-color: #f9f9f9;
  color: #333;
}

#map {
  width: 100%;
  height: 100vh;
}

.sidebar {
  width: 300px;
  background-color: #fff;
  border-left: 1px solid #ddd;
  padding: 16px;
  position: absolute;
  top: 0;
  right: 0;
  height: 100%;
  overflow-y: auto;
  box-shadow: -2px 0 5px rgba(0,0,0,0.1);
}

button {
  cursor: pointer;
  background-color: #1976d2;
  color: #fff;
  border: none;
  padding: 8px 12px;
  border-radius: 4px;
}

button:hover {
  background-color: #1565c0;
}
--
// frontend/src/components/Map.tsx
import { useEffect, useState } from "react";
import { MapContainer, TileLayer, useMapEvents, Marker } from "react-leaflet";

interface MapProps {
  onSelectPoint?: (lat: number, lon: number) => void;
}

export default function Map({ onSelectPoint }: MapProps) {
  const [isClient, setIsClient] = useState(false);
  const [marker, setMarker] = useState<[number, number] | null>(null);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) return null;

  function ClickHandler() {
    useMapEvents({
      click(e) {
        setMarker([e.latlng.lat, e.latlng.lng]);
        if (onSelectPoint) onSelectPoint(e.latlng.lat, e.latlng.lng);
      },
    });
    return null;
  }

  return (
    <MapContainer
      center={[0, 0]}
      zoom={2}
      style={{ height: "100vh", width: "100%" }}
    >
      <TileLayer
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        attribution="&copy; OpenStreetMap contributors"
      />
      <ClickHandler />
      {marker && <Marker position={marker} />}
    </MapContainer>
  );
}
--
// frontend/src/components/Sidebar.tsx
interface SidebarProps {
  lat?: number;
  lon?: number;
  indices?: Record<string, number>;
  agb?: number;
}

export default function Sidebar({ lat, lon, indices, agb }: SidebarProps) {
  return (
    <div className="sidebar">
      <h2>Selected Point</h2>
      {lat && lon ? (
        <>
          <p><strong>Latitude:</strong> {lat.toFixed(6)}</p>
          <p><strong>Longitude:</strong> {lon.toFixed(6)}</p>
        </>
      ) : (
        <p>No point selected</p>
      )}
      {indices && (
        <>
          <h3>Indices</h3>
          <ul>
            {Object.entries(indices).map(([key, value]) => (
              <li key={key}>{key}: {value.toFixed(4)}</li>
            ))}
          </ul>
        </>
      )}
      {agb !== undefined && (
        <p><strong>AGB:</strong> {agb.toFixed(2)}</p>
      )}
    </div>
  );
}
--
// frontend/src/pages/index.tsx
import dynamic from "next/dynamic";
import { useState } from "react";
import Sidebar from "../components/Sidebar";
import { fetchProcess } from "../lib/api";

const Map = dynamic(() => import("../components/Map"), { ssr: false });

export default function Home() {
  const [lat, setLat] = useState<number>();
  const [lon, setLon] = useState<number>();
  const [indices, setIndices] = useState<Record<string, number>>();
  const [agb, setAgb] = useState<number>();

  async function handleSelectPoint(selectedLat: number, selectedLon: number) {
    setLat(selectedLat);
    setLon(selectedLon);

    try {
      const res = await fetchProcess(selectedLat, selectedLon);
      setIndices(res.indices);
      setAgb(res.agb);
    } catch (err) {
      console.error(err);
    }
  }

  return (
    <div>
      <Map onSelectPoint={handleSelectPoint} />
      <Sidebar lat={lat} lon={lon} indices={indices} agb={agb} />
    </div>
  );
}
--
// frontend/src/lib/api.ts
export interface ProcessResponse {
  indices: Record<string, number>;
  agb: number;
}

export async function fetchProcess(lat: number, lon: number): Promise<ProcessResponse> {
  const res = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/process`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ lat, lon }),
  });
  if (!res.ok) throw new Error("API error");
  return res.json();
}
