# ใช้ใน Colab / Jupyter
import rasterio
from rasterio.windows import Window
from pyproj import Transformer
import numpy as np
import matplotlib.pyplot as plt
import math

# ---------- helper ----------
def linear_stretch(band, low=2, high=98):
    """QGIS-like linear stretch based on percentiles; ignore non-finite values."""
    arr = band.astype(np.float64)
    arr = arr[np.isfinite(arr)]
    if arr.size == 0:
        return np.zeros_like(band, dtype=float)
    p_low, p_high = np.percentile(arr, (low, high))
    if p_high <= p_low:
        # all values identical -> return mid-gray
        return np.ones_like(band, dtype=float) * 0.5
    out = (band.astype(np.float64) - p_low) / (p_high - p_low)
    out = np.clip(out, 0.0, 1.0)
    return out

# ---------- USER INPUT ----------
raster_path = "IMAGERY.TIF"   # เปลี่ยนเป็นไฟล์ของคุณ
lat = float(input("กรอก Latitude (N): "))
lon = float(input("กรอก Longitude (E): "))
width_m = float(input("กรอกความกว้างของพื้นที่ (เมตร): "))
height_m = float(input("กรอกความยาวของพื้นที่ (เมตร): "))

# ---------- Open raster and compute pixel window ----------
with rasterio.open(raster_path) as src:
    raster_crs = src.crs
    res_x, res_y = src.res            # e.g. (15.0, 15.0) ; res_y might be negative in transform
    height_px, width_px = src.height, src.width

    # transform lat/lon -> raster CRS (x, y)
    transformer = Transformer.from_crs("EPSG:4326", raster_crs, always_xy=True)
    x_center, y_center = transformer.transform(lon, lat)

    # get pixel row, col for center (rasterio.index returns (row, col))
    row_center, col_center = src.index(x_center, y_center)

    # compute number of pixels to cover requested meters (ceil so we cover the area)
    px_w = max(1, int(math.ceil(width_m / res_x)))           # number of columns to include
    px_h = max(1, int(math.ceil(height_m / abs(res_y))))     # number of rows to include

    # center the window around center pixel as best as possible
    c0 = max(0, col_center - px_w // 2)
    r0 = max(0, row_center - px_h // 2)
    c1 = min(width_px, c0 + px_w)
    r1 = min(height_px, r0 + px_h)

    # if window ended up empty (edge cases), force minimum 1x1 around center
    if (r1 - r0) <= 0 or (c1 - c0) <= 0:
        r0 = max(0, row_center - 1)
        c0 = max(0, col_center - 1)
        r1 = min(height_px, r0 + 3)
        c1 = min(width_px, c0 + 3)

    win_rows = r1 - r0
    win_cols = c1 - c0

    print(f"Raster CRS: {raster_crs}, resolution: ({res_x}, {res_y}) m/pix")
    print(f"Center pixel (row, col): {row_center}, {col_center}")
    print(f"Window in pixels: rows {r0}:{r1} (count={win_rows}), cols {c0}:{c1} (count={win_cols})")
    print(f"Approx area: {win_cols*res_x:.1f} m × {win_rows*abs(res_y):.1f} m  (requested {width_m}m x {height_m}m)")

    # read only the window for bands; adjust band indices if needed
    # assume bands: 1=Blue, 2=Green, 3=Red, 4=NIR
    # safe-read each band in window to avoid memory issues
    bands_to_read = [1,2,3]   # for RGB display we read B,G,R
    band_arrays = []
    for b in bands_to_read:
        arr = src.read(b, window=Window(c0, r0, win_cols, win_rows))
        band_arrays.append(arr)

# ---------- prepare visualization (QGIS-style stretch) ----------
# band_arrays are in order [B, G, R] ; for RGB we need [R,G,B]
if len(band_arrays) >= 3:
    B_win = band_arrays[0]
    G_win = band_arrays[1]
    R_win = band_arrays[2]
    R_vis = linear_stretch(R_win)
    G_vis = linear_stretch(G_win)
    B_vis = linear_stretch(B_win)
    rgb_zoom = np.dstack([R_vis, G_vis, B_vis])
else:
    # fallback: if fewer bands, show band 1 stretched as gray
    single = linear_stretch(band_arrays[0])
    rgb_zoom = np.dstack([single, single, single])

# ---------- show image ----------
plt.figure(figsize=(6,6))
plt.imshow(rgb_zoom)
plt.title(f"Zoomed (approx: {win_cols}×{win_rows} pixels) ≈ {win_cols*res_x:.1f}m × {win_rows*abs(res_y):.1f}m")
plt.axis("off")

# mark center location inside the window
center_r = row_center - r0
center_c = col_center - c0
if 0 <= center_r < rgb_zoom.shape[0] and 0 <= center_c < rgb_zoom.shape[1]:
    plt.scatter([center_c], [center_r], s=80, marker='o', c='yellow', edgecolors='black')
plt.show()
