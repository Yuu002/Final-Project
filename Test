# mlp_model.py
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPRegressor
import joblib

def train_mlp_model():
    # Load dataset
    data = pd.read_csv("bands_extracted.csv")

    # X = Sentinel reflectance
    X = data[["Band1", "Band2", "Band3", "Band4"]].values
    # y = Field reflectance
    y = data[["Blue (B1)", "Green (B2)", "Red (B3)", "NIR (B4)"]].values

    # Scale
    scaler_X = StandardScaler()
    X_scaled = scaler_X.fit_transform(X)

    scaler_y = StandardScaler()
    y_scaled = scaler_y.fit_transform(y)

    # Train/test split
    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y_scaled, test_size=0.2, random_state=42
    )

    # Train MLP
    mlp = MLPRegressor(hidden_layer_sizes=(64,64,32), max_iter=500, random_state=42)
    mlp.fit(X_train, y_train)

    # Save model & scalers
    joblib.dump(mlp, "mlp_model.pkl")
    joblib.dump(scaler_X, "scaler_X.save")
    joblib.dump(scaler_y, "scaler_y.save")
    print("‚úÖ MLP model saved successfully.")

def load_mlp_model():
    mlp = joblib.load("mlp_model.pkl")
    scaler_X = joblib.load("scaler_X.save")
    scaler_y = joblib.load("scaler_y.save")
    return mlp, scaler_X, scaler_y
--
# indices.py
import numpy as np

def calculate_indices(red, nir, blue=None, green=None, L=0.5):
    """
    ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì NDVI, TNDVI, SR, SAVI, MSAVI2
    """
    red = np.array(red, dtype=float)
    nir = np.array(nir, dtype=float)

    ndvi = (nir - red) / (nir + red + 1e-6)
    tndvi = np.sqrt(np.clip(ndvi + 0.5, a_min=0.0, a_max=None))
    sr = nir / (red + 1e-6)
    savi = ((1 + L) * (nir - red)) / (nir + red + L + 1e-6)
    msavi2 = (2 * nir + 1 - np.sqrt((2 * nir + 1) ** 2 - 8 * (nir - red))) / 2

    return {
        "NDVI": float(np.nanmean(ndvi)),
        "TNDVI": float(np.nanmean(tndvi)),
        "SR": float(np.nanmean(sr)),
        "SAVI": float(np.nanmean(savi)),
        "MSAVI2": float(np.nanmean(msavi2)),
    }
--
# svr_model.py
import pandas as pd
from sklearn.svm import SVR
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import joblib

def train_svr_model():
    # Load training data (‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå indices_agb.csv ‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡πà‡∏≤ indices + AGB ‡∏à‡∏£‡∏¥‡∏á)
    data = pd.read_csv("indices_agb.csv")

    X = data[["NDVI", "TNDVI", "SR", "SAVI", "MSAVI2"]].values
    y = data["AGB"].values

    # Scale
    scaler_X = StandardScaler()
    X_scaled = scaler_X.fit_transform(X)

    scaler_y = StandardScaler()
    y_scaled = scaler_y.fit_transform(y.reshape(-1,1)).ravel()

    # Train/test split
    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y_scaled, test_size=0.2, random_state=42
    )

    svr = SVR(kernel="rbf")
    svr.fit(X_train, y_train)

    # Save
    joblib.dump(svr, "svr_agb_model.pkl")
    joblib.dump(scaler_X, "svr_scaler_X.save")
    joblib.dump(scaler_y, "svr_scaler_y.save")
    print("‚úÖ SVR model saved successfully.")

def load_svr_model():
    svr = joblib.load("svr_agb_model.pkl")
    scaler_X = joblib.load("svr_scaler_X.save")
    scaler_y = joblib.load("svr_scaler_y.save")
    return svr, scaler_X, scaler_y
---
from flask import Flask, render_template, request, jsonify
import ee
import numpy as np
import joblib

from mlp_model import load_mlp_model
from svr_model import load_svr_model
from indices import calculate_indices

# Initialize Earth Engine
ee.Initialize(project='map-web-473508')

app = Flask(__name__)

# ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•
mlp, scaler_X, scaler_y = load_mlp_model()
svr, svr_scaler_X, svr_scaler_y = load_svr_model()

# -----------------------------
def mask_s2_clouds_theos(image):
    qa = image.select('QA60')
    cloud_bit_mask = 1 << 10
    cirrus_bit_mask = 1 << 11
    mask = qa.bitwiseAnd(cloud_bit_mask).eq(0).And(
        qa.bitwiseAnd(cirrus_bit_mask).eq(0)
    )

    reflectance = image.divide(10000)  # Sentinel SR 0‚Äì10000 ‚Üí 0‚Äì1
    theos_reflectance = reflectance.multiply(100)  # THEOS-style 0‚Äì100

    return theos_reflectance.updateMask(mask)

# -----------------------------
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/process_pixel', methods=['POST'])
def process_pixel():
    lat = float(request.json['lat'])
    lon = float(request.json['lon'])
    start = request.json['start']
    end = request.json['end']

    point = ee.Geometry.Point([lon, lat])

    collection = (ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
                  .filterDate(start, end)
                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 20))
                  .map(mask_s2_clouds_theos))

    image = collection.mean()

    bands = image.reduceRegion(
        reducer=ee.Reducer.first(),
        geometry=point,
        scale=10
    ).getInfo()

    # Sentinel reflectance (input to MLP)
    X_input = np.array([[bands['B2'], bands['B3'], bands['B4'], bands['B8']]])  # Blue, Green, Red, NIR
    X_scaled = scaler_X.transform(X_input)
    field_reflectance_scaled = mlp.predict(X_scaled)
    field_reflectance = scaler_y.inverse_transform(field_reflectance_scaled)

    blue, green, red, nir = field_reflectance[0]

    # Calculate indices
    indices = calculate_indices(red, nir, blue, green)

    # Predict AGB using SVR
    X_indices = np.array([[indices["NDVI"], indices["TNDVI"], indices["SR"], indices["SAVI"], indices["MSAVI2"]]])
    X_indices_scaled = svr_scaler_X.transform(X_indices)
    agb_scaled = svr.predict(X_indices_scaled)
    agb = svr_scaler_y.inverse_transform(agb_scaled.reshape(-1,1))[0][0]

    return jsonify({
        "field_reflectance": {
            "Blue": float(blue),
            "Green": float(green),
            "Red": float(red),
            "NIR": float(nir)
        },
        "indices": indices,
        "AGB": float(agb)
    })

if __name__ == '__main__':
    app.run(debug=True)
--
<!DOCTYPE html>
<html>
<head>
  <title>AGB Estimation</title>
</head>
<body>
  <h2>üåø AGB Estimation System</h2>
  <form id="pixelForm">
    <label>Lat: <input type="text" id="lat" value="18.0"></label>
    <label>Lon: <input type="text" id="lon" value="100.0"></label>
    <label>Start: <input type="date" id="start" value="2020-01-01"></label>
    <label>End: <input type="date" id="end" value="2020-01-15"></label>
    <button type="submit">Process</button>
  </form>

  <pre id="output"></pre>

  <script>
    document.getElementById("pixelForm").addEventListener("submit", async function(e){
      e.preventDefault();
      const lat = document.getElementById("lat").value;
      const lon = document.getElementById("lon").value;
      const start = document.getElementById("start").value;
      const end = document.getElementById("end").value;

      const res = await fetch("/process_pixel", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({lat, lon, start, end})
      });

      const data = await res.json();
      document.getElementById("output").textContent = JSON.stringify(data, null, 2);
    });
  </script>
</body>
</html>
--
flask
earthengine-api
joblib
numpy
scikit-learn
pandas
